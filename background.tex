\chapter{Background Survey \& Related Work}\label{C:background}

\section{Collaborative Filtering}

Historically, people have relied on recommendations and mentions
from their peers or the advice of experts to support decisions and discover
new material 

collaborative filtering, a class of methods that
recommend items to users based on the preferences other users have
expressed for those items.
There is also a growing interest in problems surrounding
recommendation. Algorithms for understanding and predicting user
preferences do not exist in a vacuum — they are merely one piece of
a broader user experience. A recommender system must interact with
the user, both to learn the user’s preferences and provide recommendations;
these concerns pose challenges for user interface and interaction
design. Systems must have accurate data from which to compute their
recommendations and preferences, leading to work on how to collect
reliable data and reduce the noise in user preference data sets. Users
also have many different goals and needs when they approach systems,
from basic needs for information to more complex desires for privacy
with regards to their preferences.

In his keynote address at the 2009 ACM Conference on Recommender Systems,Martin \cite{martin2009recsys} argued that algorithms themselves are only a small part of the problem of providing recommendations to users. We haev a number of algorithms that work fairly well, and while there is room to refine them, there is much work to be done on user experience, data colelction, and other problems which make up the whole of the recommender experience. 

Collaborative filtering (CF) is a popular recommendation algorithm
that bases its predictions and recommendations on the ratings or behavior
of other users in the system.

There are other methods for performing recommendation, such as
finding items similar to the items liked by a user using textual similarity
in metadata (content-based filtering or CBF). The focus of this survey
is on collaborative filtering methods, although content-based filtering
will enter our discussion at times when it is relevant to overcoming a particular recommender system difficulty.

\cite{schafer2007collaborative}

TODO: reword.
Collaborative filtering is a recommendation algorithm that predicts items (filtering) about the interests of a user by collecting preferences or taste information from other users (collaborating). The underlying assumption of the collaborative filtering approach is that similar users will have similar tastes, thus we can make recommendations based on this idea. 

Collaborative Filtering is a technique used in many recommender systems. The main idea behind collaborative filtering is to analyse previous user behaviour such as their previous ratings on items to find trends in these patterns. By learning these trends this technique is able to identify new user item relationships to recommend items that the user may have not seen yet. 


However, this means that the algorithm is reliant on previous user behaviour to give good recommendations. This makes collaborative filtering difficult to address new products and users. This problem is referred to as the 'Cold Start' problem where there are not many users who have rated any items yet. (Content based filtering is superior in this context). However, the advantage of Collaborative filtering is that does not require domain knowledge of the products and users. It purely focuses on the previous user rating actions, and recommendations are generally more accurate than Content based filtering \cite{koren2009matrix}. 

There are two main areas that encompass collaborative filtering, these areas are neighborhood methods and latent factor models which will be explained in detail further on. 

% \section{Challenges}
% \subsection{Cold Start}
% \subsection{Data Sparsity}
% \subsection{Synonyms}
% \subsection{Scalability}
% \subsection{Grey Sheep}
% \subsection{Shilling attacks}
% \subsection{Diversity and the Long Tail}

\section{Neighbourhood Methods}


Neighbourhood methods cluster together items or users that are most similar to each other according to similarity measures. Users and items are treated 

\subsection{User Based Collaborative Filtering}

It was first introduced in the GroupLens Usenet article recommender \cite{grouplens}. 

User based collaborative filtering uses a similarity measure to find users that are similar to each other, and then recommends food based on this metric. User based collaborative filtering methods aim at finding users that are similar to one another, and recommending items to them based on each of their previous behaviours. There is high chance that similar users will prefer similar items. For example, two users may like eating spicy food. the first user has indicated that they like eating chicken vindaloo and hot chilli peppers. The second user has indicated that they like eating hot chilli peppers. Therefore, since these two users previous behaviours are similar as they both have indicated their enjoyment of hot chilli peppers, they are to be considered similar. We can recommend to the second user that they should try chicken vindaloo, since the first user liked it and the two users have similar tastes.  


\subsection{Item Based Collaborative Filtering}

Another approach that is commonly used is called item based collaborative filtering. Instead of finding users that are similar to one another, item based collaborative filtering focuses on previous behaviour of the user, and recommends similar new items based on what items the user previously liked. Item based collaborative filtering differs to user based collaborative filtering because it uses a similarity measure to find similar items to items that the user has already indicated interest in. For example, a user could have previously liked the following dishes: a chicken sandwich, chicken nuggets, and chicken soup. Item based collaborative filtering will find similar items to this user by using a similarity measure on their previous items they indicated they liked. By using this technique, it may recommend new items to the user such as chicken salad, or a chicken burger since all those items contain chicken. This is the main idea behind item based collaborative filtering. 

\cite{schafer2007collaborative}

 Rather than using
similarities between users’ rating behavior to predict preferences, item–
item CF uses similarities between the rating patterns of items. If two
items tend to have the same users like and dislike them, then they are
similar and users are expected to have similar preferences for similar
items. In its overall structure, therefore, this method is similar to earlier
content-based approaches to recommendation and personalization, but
item similarity is deduced from user preference patterns rather than
extracted from item data.


\subsubsection{Slope One}

\subsection{Challenges}
A key problem of collaborative filtering is how to combine and weight the preferences of user neighbors. Sometimes, users can immediately rate the recommended items. As a result, the system gains an increasingly accurate representation of user preferences over time.

\subsection{Similarity Measures}
\subsubsection{Pearson's Coefficient}
\subsubsection{Euclidean Distance \& Manhattan Distance}
\subsubsection{Cosine Similarity}
\subsubsection{Jaccard Index}

\section{Latent Factor Methods}

Latent factor models look at analysing the previous actions of users and creating a feature vectors for items and users. These item and user features are used to predict future items that the user may like. 

\subsection{Singular Value Decomposition}
\subsubsection{Stochastic Gradient Descent}
\subsubsection{Alternating Least Squares}


\section{Literature Review}

The term 'collaborative filtering' was first introduced in \citeyear{goldberg1992using} by \citeauthor{goldberg1992using} to describe the technique used in Tapestry, one of the earliest known recommender systems \cite{koren2009matrix,  goldberg1992using, itembased, survey}.

Tapestry \cite{goldberg1992using} was created to handle electronic documents and used manual collaborative filtering, allowing users to query information based on others opinions about the documents. These opinions were in the form of annotations or replies which users were encouraged to make on documents to increase probability of relevant results returned from queries \cite{schafer2007collaborative}. Tapestry relied on opinions from a small community such as an office workgroup, where each person's opinion was trusted. Larger communities could not rely on every person knowing each other, leading to new collaborative filtering techniques being developed \cite{itembased}. 

More recommender systems emerged as value was seen in the potential to increase sales from recommendations - customers may purchase suggested items that they might not have seen otherwise \cite{schafer2007collaborative}. Perhaps the most popular recommender system in the late 1990's was used in Amazon.com, collecting user purchase history, browsing history, and recently viewed items to recommend items that the user may buy \cite{schafer2007collaborative}. Other recommender systems consisted of Jester \cite{goldberg} for jokes, and Ringo \cite{ringo} for music.
% /cite{schafer2007collaborative, toward}
GroupLens \cite{grouplens} were the first to introduce a neighbourhood collaborative filtering technique. Building upon the Tapestry concept, GroupLens created an automated user based collaborative filtering technique for recommending Usenet articles that users may be interested in. The advantage of neighbourhood methods is that they are intuitive, easy to implement, and produce highly effective results \cite{survey, scalable}. Despite providing accurate recommendations, user-based collaborative filtering techniques were computed in real time and performance would degrade as more users and items were added to the system, leading to scalability and performance issues \cite{dimension, itembased, evaluationitem}.

This required collaborative filtering techniques that could easily scale and still produce high quality recommendations leading to the exploration of item-based collaborative filtering. Item-based collaborative filtering techniques were developed to address scalability limitations of the user-based techniques \cite{survey}. \citeauthor{itembased} analyzed various item-based recommendation algorithms, computing item-item similarities and comparing the accuracy with traditional KNN user based collaborative filtering techniques \cite{itembased}. \citeauthor{itembased} found that items remained fairly static in the system, whereas user behaviours and preferences would often change. Because items were found mostly static, it meant precomputation could occur for item similarities. By having precomputed item similarities, traditional item-based collaborative filtering can then be applied, thus performance and scalability would be increased \cite{scalable}.

Other techniques such as model based collaborative filtering have been investigated to overcome the performance and scalability issues. Well known model based techniques include Bayesian belief nets \cite{baysian}, clustering models \cite{clustering}, and latent semantic models \cite{latent}. These models are based on learning patterns from users previous actions to predict new items, and are expensive but can be built offline allowing high scalability. The resulting model is "very small, very fast, and essentially as accurate as nearest neighbor methods" \cite{itembased}. \citeauthor{itembased} found Bayesian networks to be practical in the context where user "preferences change slowly with respect to the model" \cite{itembased}. However, these models are not suitable for environments where the user preference model should be updated rapidly or frequently. Since model based approaches do not have to compute similarity measures to form neighbourhoods, they tend to produce faster recommendations and outperform neighbourhood models in terms of accuracy of recommendations \cite{toward, itembased}. 

Although collaborative filtering is considered to be one of the most successful approaches to recommender systems \cite{survey, toward}, they suffer from the problem of data sparsity \cite{toward, survey, itembased, koren2009matrix, koren2011, dimension}. Data sparsity is when only a small subset of user ratings on items are recorded, leading to a insufficient number of ratings to produce accurate recommendations. Data sparsity specifically tends to appear in the 'cold start' problem, where new items or new users are entered into the system, but not enough information is supplied to produce accurate recommendations since recommendations are based on common items or users \cite{survey}.

To alleviate this problem, hybrid approaches were investigated that combined collaborative filtering and other recommender techniques such as content based filtering. \citeauthor{toward} suggested creating user profiles such that demographic information could be included in similarity measures to provide extra content to find similar users or items. This effectively makes use of content-based filtering where recommendations are produced based on the content and attributes of the items, learning what attributes the user likes \cite{toward}. Well-known hybrid techniques include content-boosted collaborative filtering \cite{hybrid}, and personality diagnosis \cite{hybrid2, survey}. Hybrid approaches were implemented to address the limitations of collaborative filtering and content-based filtering techniques \cite{toward}, but have increased complexity leading to more expensive computations. Additionally, external information is needed about the content of the items which may not be available, thus making hybrid approaches impractical in certain scenarios \cite{survey}. \citeauthor{dimension} found a different approach that used dimension reduction techniques such as Singular Value Decomposition, making sparse rating models more dense by reducing the dimensionality of the product space, thereby condensing the modelled ratings of users and producing less missing information \cite{dimension}. 

In 2006, the Netflix Prize competition attracted interest in the field of recommender systems \cite{survey}. Netflix offered a \$ 1 million dollar prize to the first team to improve their movie recommender system by 10\%. This attracted interest in the research field of recommender systems. The team "BellKor in Pragmatic Chaos" won the competition in 2009 basing their solution on a combination of latent factor models and neighbourhood models \cite{winning, survey}. These models took into account many biases which improved the predication accuracy. \citeauthor{koren2009matrix} were part of the winning team, and wrote a paper explaining how temporal effects, and user biases could be accounted for in latent factor models such as Singular Value Decomposition, making it superior to neighbourhood methods \cite{koren2009matrix}. \citeauthor{koren2011} later published a paper about their findings and solutions to the Netflix Prize competition in \cite{koren2011} and \cite{winners}.


\section{Discussion of Literature Review}

TODO: DELETE?

Although actions from users are required to provide personalised results, the advantage of collaborative filtering is that no prior knowledge or context is required about the items to provide recommendations to users. Items could be recommended to users purely based on past behaviour from others \cite{koren2009matrix, schafer2007collaborative}. 

For this reason, collaborative filtering is preferred over content based filtering, a technique where items are recommended based on learning users preferences from previous items that users liked, and recommending similar items based on the attributes of those items. Additionally, content based filtering is prone to recommending only a small subset of items, since it recommended items based on the attributes that the user liked. Traditional collaborative filtering is able to address this concern since attributes are ignored, and recommendations are based on actions of other users, providing a range of recommendations that are not restricted to specific attributes, generally being more accurate \cite{koren2009matrix}.  In content based filtering it is also hard to extract features or would have to be manually put in which may not be practical \cite{toward}. Another problem is overspecialization, recommending only similar items to users thus restricting variety \cite{toward}.



It is evident that there has been an abundance of existing research on collaborative filtering techniques and ways to improve the prediction accuracy. However, \citeauthor{schafer2007collaborative} states these factors alone, do not contribute to making a good recommender system \cite{schafer2007collaborative}. Instead, \citeauthor{schafer2007collaborative} states that recommendation is not a "one-size-fits-all problem"  \cite{schafer2007collaborative}. Specific tasks, information needs, and item domains represent unique problems for recommenders, and design and evaluation of recommenders needs to be done based on the user tasks to be supported" \cite{schafer2007collaborative}. Similarly, \citeauthor{martin2009recsys} argues that the recommender algorithms is only one factor from many for providing recommendations to users. \citeauthor{martin2009recsys} explains that the user experience, data collection, and other problems which make up the whole of the recommender experience need to be considered \cite{schafer2007collaborative, martin2009recsys}. \citeauthor{interface} concluded in \cite{interface} that much of the accuracy problem has been solved in recommender systems, however delivering these accurate predictions to users in a way that creates the "best experience for them remains an open problem" \cite{interface}. 

For this reason, this project focuses on the goal of providing a recommender system that fits the needs for the "What's On The Menu" application. This involves considering how users ratings will be collected, the user experience, the recommendation process, and what factors are considered to be important in the recommendation process such as scalability, prediction accuracy, and performance.








TODO: remove this? Do I talk about this stuff here?


Existing research also focuses on the scalability and performance of these collaborative filtering techniques. In terms of scalability, the "What's On The Menu" application is not expected to contain anywhere near the number of users or items as existing recommender systems used by Netflix, Facebook, and Google. For this reason, neighbourhood methods may be a good choice, as they provide for the ability to explain the reasoning behind the recommendations, as well as give good accurate results. Scalability should not be a top concern with this application. Therefore, real time computation may be a factor to consider. 

The main focus of the recommender system will be on how to make the user experience as easy as possible for the users. This will enable the collection of user data to provide these recommendations. Another focus will be on the performance in which the recommender system can provide recommendations to the users. In this case, prediction accuracy may be less important than the speed and the performance of recommendations being produced. If the recommendation process is slow, then users will be less likely to continue using the application. On the other hand, if prediction accuracy is not very good, then users will be recommended items that they may potentially not like. A fair trade-off must be considered. 

% + main challenges, sparsity \cite{survey, dimension}, scalability, synonymy \cite{dimension}, gray sheep, shilling attacks, privacy protection, etc \cite{survey}.

\section{Representational State Transfer (REST)}

REST stands for REpresentational State Transfer. REST is an architectural style for building a software application that can be used to communicate to other systems through the HTTP protocol. It uses resources to represent important data that can be retrieved by other systems via methods from the HTTP Protocol (GET, POST, PUT, DELETE etc). It utilizes a client-server, and is stateless in the sense that all the data that is needed is sent through the HTTP protocol to the other system.

\section{Application Program Interface (API)}

API stands for Application Program Interface. An API describes the methods and ways in which others can interact and use these tools to build software applications. It specifies how software components should interact and how the software methods, or services behave. 